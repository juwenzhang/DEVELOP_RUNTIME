# async_hooks

> 异步钩子 🪝

:::tip

官方对应网页：https://nodejs.org/docs/latest/api/async_hooks.html

> Asynchronous context tracking 异步上下文追踪

:::

:::warning

官网描述：

我们极其不建议使用 `async_hooks` API，因为其他的 API 可以绝大程度上覆盖其使用场景

    * `AsyncLocalStorage` 跟踪异步上下文

    * `process.getActiveResourcesInfo` 跟踪激活的资源

:::

## 概念

:::info

* 异步资源表示一个带有相关回调的对象。

    * 这个回调可能被调用多次（`multi-times`），比如网络请求：`net.createServer()` 中的 `connection` 事件

    * 也可能只是调用一次(`single-time`)，比如`fs.open()` 里的情况。
    
    * 资也可能在回调被调用前就被关闭

* 但是 `AsyncHooks` 是不会对其进行一个严格区分，统一称为 `资源`

> 如果使用了线程 `worker` ，每一个线程都是有一个独立的 `async_hooks` 的接口，每个线程都会使用一组新的异步 `ID`

```javascript
const async_hooks = require('node:async_hooks');

// Return the ID of the current execution context.
const eid = async_hooks.executionAsyncId();

// Return the ID of the handle responsible for triggering the callback of the
// current execution scope to call.
const tid = async_hooks.triggerAsyncId();

// Create a new AsyncHook instance. All of these callbacks are optional.
const asyncHook =
    async_hooks.createHook({ init, before, after, destroy, promiseResolve });

// Allow callbacks of this AsyncHook instance to call. This is not an implicit
// action after running the constructor, and must be explicitly run to begin
// executing callbacks.
asyncHook.enable();

// Disable listening for new asynchronous events.
asyncHook.disable();

//
// The following are the callbacks that can be passed to createHook().
//

// init() is called during object construction. The resource may not have
// completed construction when this callback runs. Therefore, all fields of the
// resource referenced by "asyncId" may not have been populated.
function init(asyncId, type, triggerAsyncId, resource) { }

// before() is called just before the resource's callback is called. It can be
// called 0-N times for handles (such as TCPWrap), and will be called exactly 1
// time for requests (such as FSReqCallback).
function before(asyncId) { }

// after() is called just after the resource's callback has finished.
function after(asyncId) { }

// destroy() is called when the resource is destroyed.
function destroy(asyncId) { }

// promiseResolve() is called only for promise resources, when the
// resolve() function passed to the Promise constructor is invoked
// (either directly or through other means of resolving a promise).
function promiseResolve(asyncId) { }
```

:::

## `async_hooks.createHook(callbacks)`

* callbacks 实现的是定义一个对象的数据类型吧，以及在内部会实现注册一些回调事件吧，返回的是 async_hooks 的实例

    * init() `function` 初始化时执行回调

    * before() `function` 执行前的回调

    * after()  `function` 回调后的执行回调

    * destory() `function` 销毁时的执行回调

    * promiseResolve()

* 这些注册的函数会被调用在每个异步操作的不用生命周期中

* 在一个资源的生命周期内，回调函数 init()、before()、after()、destroy() 会针对各自相应的异步事件被调用

:::tip

* 所有的回调函数都是可选的，思想的话是和比如说一些打包的配置或者说组件的生命周期函数的使用类似，都是可选择

```javascript
const async_hooks = require("node:async_hooks")
const asyncHooksInstance = async_hooks.createHook({
    init(asyncId, type, triggerAsyncId, resource) {},
    destory(asyncId) {}
})
```

:::

:::details

* 更详细的例子

```javascript
const async_hooks = require('node:async_hooks');

class MyAsyncCallback {
    init(asyncId, type, triggerAsyncId, resource) {}
    destroy(asyncId) {}
}

class MyAsyncCallbackWithAfter extends MyAsyncCallback {
    after(asyncId) {}
}

class MyAsyncCallbackWithBefore extends MyAsyncCallback {
    before(asyncId) {}
}

class MyAsyncCallbackWithPromiseResolve extends MyAsyncCallback {
    promiseResolve(asyncId) {}
}

class MyAsyncCallbackWithAll extends MyAsyncCallbackWithAfter {
    before(asyncId) {}
    after(asyncId) {}
    promiseResolve(asyncId) {}
}

const myAsyncCallbackWithAll = new MyAsyncCallbackWithAll();
const asyncHookInstanceAll = async_hooks.createHook(myAsyncCallbackWithAll);

module.exports = {
    myAsyncCallbackWithAll,
    asyncHookInstanceAll
}
```

:::

## `AsyncHookInstance.enable()`

* 首先上面的案例已经说明了 craeetHook 实现的是创建对应的实例出来的

* 对于实例的话也是有一些实例方法的呐

:::info

为给定的 AsyncHook 实例启用回调。如果没有提供回调，启用操作不会产生任何效果。
AsyncHook 实例默认是禁用的。如果 AsyncHook 实例应该在创建后立即启用，可以使用以下模式

:::

## `AsyncHookInstance.disable()`

:::tip

从要执行的 AsyncHook 全局回调池中，禁用给定 AsyncHook 实例的回调。一旦一个钩子被禁用，在重新启用之前，它将不会再被调用。
为了 API 的一致性，disable() 也会返回该 AsyncHook 实例。

:::

## `Hook callbacks`

### `init`
:::info

异步事件生命周期中的关键事件被归类为四个方面：实例化、回调调用前/后，以及实例销毁时。

* init(asyncId, type, triggerAsyncId, resource)
    * asyncId number：异步资源的唯一 ID。
    * type string：异步资源的类型。
    * triggerAsyncId number：在其执行上下文中创建此异步资源的异步资源的唯一 ID。
    * resource Object：表示异步操作的资源的引用，需要在 `destroy` 时释放。

当构造一个有可能发出异步事件的类时调用。这并不意味着实例必须在 `destroy` 被调用前调用 `before` / `after`，只是存在这种可能性。

这种行为可以通过类似这样的操作来观察：打开一个资源，然后在该资源可被使用前关闭它。下面的代码片段演示了这一点。

```javascript
require('node:net').createServer().listen(function() { this.close(); });
clearTimeout(setTimeout(() => {}, 10));
```

每个新资源都会被分配一个在当前 Node.js 实例范围内唯一的 ID。

:::

:::details

* `type`
    * type 是一个字符串，用于标识导致 init 被调用的资源类型。通常，它与资源构造函数的名称相对应。
    * Node.js 自身创建的资源的 type 在 Node.js 的任何版本中都可能发生变化。有效的值包括 TLSWRAP、TCPWRAP、TCPSERVERWRAP、GETADDRINFOREQWRAP、FSREQCALLBACK、Microtask 和 Timeout。要获取完整列表，请查看所使用的 Node.js 版本的源代码。
    * 此外，AsyncResource 的用户可以独立于 Node.js 自身创建异步资源。
    * 还有 PROMISE 资源类型，用于跟踪 Promise 实例以及由它们调度的异步工作。
    * 当使用公共嵌入器 API 时，用户能够定义自己的 type。
    * 可能会出现类型名称冲突的情况。建议嵌入器使用唯一的前缀（例如 npm 包名称），以防止在监听钩子时发生冲突。

* `triggerAsyncId`
    * triggerAsyncId 是导致（或 “触发”）新资源初始化并使得 init 被调用的资源的 asyncId。这与 async_hooks.executionAsyncId() 不同，async_hooks.executionAsyncId() 仅显示资源何时被创建，而 triggerAsyncId 显示资源为何被创建。

:::

## Each Callback 

:::info

| 回调函数         | 触发时机                                                                 | 核心参数                                                                 | 核心作用                                                                 | 典型应用场景                                                                 |
|------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|------------------------------------------------------------------------------|
| `init`           | 异步资源初始化时触发（如创建 Promise、定时器、网络请求等）               | `asyncId`（当前资源唯一ID）、`type`（资源类型）、`triggerAsyncId`（触发者ID）、`resource`（资源对象） | 记录异步资源的创建信息，建立资源间的关联关系（如父子调用链）             | 生成追踪ID（traceId）、记录资源类型/创建时间、初始化上下文存储               |
| `before`         | 异步资源的回调函数执行前触发（若资源有多个回调，会多次触发）             | `asyncId`（当前资源ID）                                                 | 准备回调执行的上下文环境，恢复之前保存的状态                             | 注入日志上下文（如请求ID）、性能监控的“开始计时”                             |
| `after`          | 异步资源的回调函数执行后立即触发（若回调抛错，在 `uncaughtException` 后触发） | `asyncId`（当前资源ID）                                                 | 清理回调执行后的临时状态，记录执行结果                                   | 性能监控的“结束计时并计算耗时”、清理临时变量避免内存泄漏                       |
| `destroy`        | 异步资源被销毁时触发（依赖垃圾回收，可能因内存泄漏不触发）               | `asyncId`（当前资源ID）                                                 | 释放资源关联的持久化数据，确保资源完全回收                               | 清理与资源绑定的缓存/连接、记录资源生命周期完整日志                           |
| `promiseResolve` | Promise 的 `resolve` 被调用时触发（包括 `.then` 隐式创建的 Promise）      | `asyncId`（当前 Promise 的ID）                                          | 追踪 Promise 解析过程，补全异步链中 Promise 相关的生命周期               | 完善 Promise 异步流的追踪（因原生 `async_hooks` 对 Promise 支持需显式处理） |

> demo:

```javascript
const async_hooks = require('node:async_hooks');

// 创建钩子实例
// 定义我们关心的资源类型
const interestedTypes = new Set(['Timeout', 'Promise']);

// 限制日志输出数量
let logCount = 0;
const maxLogs = 50;

// 安全的日志函数
function safeLog(...args) {
  if (logCount < maxLogs) {
    // 使用原始的process.stdout.write避免触发更多异步钩子
    process.stdout.write(args.join(' ') + '\n');
    logCount++;
  }
}

const hook = async_hooks.createHook({
  init(asyncId, type, triggerAsyncId, resource) {
    // 只记录我们关心的资源类型
    if (interestedTypes.has(type)) {
      safeLog(`[init] 资源类型: ${type}, ID: ${asyncId}, 触发者ID: ${triggerAsyncId}`);
    }
  },
  before(asyncId) {
    // before事件通常不做过滤
    safeLog(`[before] 资源 ${asyncId} 的回调即将执行`);
  },
  after(asyncId) {
    // after事件通常不做过滤
    safeLog(`[after] 资源 ${asyncId} 的回调执行完成`);
  },
  destroy(asyncId) {
    // destroy事件通常不做过滤
    safeLog(`[destroy] 资源 ${asyncId} 已销毁`);
  },
  promiseResolve(asyncId) {
    // 只记录Promise解析事件
    safeLog(`[promiseResolve] Promise ${asyncId} 已解析`);
  }
});

// 启用钩子
hook.enable();

// 测试异步资源（定时器）
setTimeout(() => {
  process.stdout.write('定时器回调执行\n');
  
  // 3秒后禁用钩子并退出进程
  setTimeout(() => {
    process.stdout.write('演示完成，禁用钩子并退出\n');
    hook.disable();
    process.exit(0);
  }, 3000);
}, 100);

// 测试Promise
Promise.resolve().then(() => {
  process.stdout.write('Promise回调执行\n');
});
```

* 这里注意一点，就是我们的 `console.log()` 的话本身也是一个异步资源函数，所以说在进行日志答应的时候会出现异步资源回调的循环触发
* 所以说对于官方的案例以及我们的测试案例实践答应主要是用的：`process.stdout.write()` 进行的答应吧
* 以及在 async_hooks 内的内部的 callback 的话尽可能不要出现异步的执行函数吧，尽可能使用同步的操作实现

:::

:::details

* `TCPSERVERWRAP`: 就是接收到连接的服务器类型
* `TCPWRAP`: 来自于客户端新的连接，当一个新的连接进来，那么TCPWrap 实例立即被创建

```
  root(1)
     ^
     |
TickObject(6)
     ^
     |
 Timeout(7)
```

```
 bootstrap(1)
     |
     ˅
TCPSERVERWRAP(5)
     |
     ˅
 TickObject(6)
     |
     ˅
  Timeout(7)
```

* 尽管 `TCPSERVERWRAP` 是调用 `console.log()` 的原因，但它并未出现在此图中。这是因为在不指定主机名的情况下绑定端口是一个同步操作，不过为了维持完全异步的 API，用户的回调函数会被放入 `process.nextTick()` 中。这就是为什么 `TickObject` 会出现在输出中，并且是 `.listen()` 回调函数的父级。

:::

:::tip

这句话核心想表达的是 **Node.js 内部对“同步操作的异步 API 封装逻辑”**，具体可以拆解为两层意思：

1. **表面现象**：  
   TCPSERVERWRAP（Node.js 内部处理 TCP 服务器的底层对象）明明是触发 console.log() 的源头，却没出现在异步调用关系图里；反而 TickObject 出现在图中，还作为 .listen() 回调的“父级”。

2. **深层原因**：  
   当调用 TCP 服务器的 .listen() 方法且不指定主机名时，“绑定端口”这个操作本身是**同步**完成的。但 Node.js 为了对外暴露**统一的异步 API 体验**（避免同步操作阻塞事件循环），会把用户传入的 .listen() 回调函数，通过 process.nextTick() 放到下一个事件循环的“微任务队列”中执行。  
   这就导致：原本同步的操作被包装成了异步执行逻辑，而 TickObject 正是 process.nextTick() 产生的内部对象，因此在异步调用链中，它成了 .listen() 回调的直接“父级”，替代了实际触发操作的 TCPSERVERWRAP 出现在调用关系里。

简单说就是：Node.js 用 process.nextTick() 把一个“同步操作的结果”强行塞进了异步流程，目的是保证 API 行为的一致性（对外始终表现为异步），这才造成了调用关系图里的“看似矛盾”的现象。

:::

## `AsyncLocalStorage` AND `AsyncResource`

### 核心概念总结

#### AsyncLocalStorage
- 用于在异步操作链中共享状态的机制，无需通过参数传递上下文（如请求ID、用户信息等）
- 基于异步资源生命周期自动绑定上下文，支持嵌套异步操作（Promise、定时器、I/O等）
- 核心原理：借助 `async_hooks` 追踪异步资源创建/执行时机，自动关联和切换上下文

#### AsyncResource
- 手动创建异步资源的工具类，用于包装原生 `async_hooks` 未覆盖的自定义异步操作
- 允许为自定义异步操作注入生命周期钩子，使其可被 `async_hooks` 追踪
- 常与 `AsyncLocalStorage` 配合，确保自定义异步操作能共享上下文

### API文档总结

#### AsyncLocalStorage API

| 方法                | 描述                                                                 |
|---------------------|----------------------------------------------------------------------|
| `new AsyncLocalStorage()` | 创建实例                                                             |
| `run(context, callback)`  | 运行回调函数，为当前及后续异步操作绑定 `context`                      |
| `enterWith(context)`     | 为当前执行上下文绑定 `context`（无需包裹回调，慎用）                  |
| `getStore()`             | 获取当前上下文的 `context`，无上下文时返回 `undefined`                |
| `disable()`              | 禁用实例，释放内部资源（调用后无法再使用）                            |

#### AsyncResource API

| 方法/属性                | 描述                                                                 |
|--------------------------|----------------------------------------------------------------------|
| `new AsyncResource(type, options)` | 创建实例，`type` 为资源类型（如 'MY_CUSTOM_ASYNC'），`options` 含可选配置（如 `triggerAsyncId`） |
| `runInAsyncScope(callback, thisArg, ...args)` | 在当前资源上下文内执行回调，确保 `async_hooks` 可追踪此操作          |
| `emitDestroy()`          | 手动触发资源的 `destroy` 钩子（需配合 `async_hooks` 使用）            |
| `asyncId`                | 资源的唯一ID（只读）                                                 |
| `triggerAsyncId`         | 触发当前资源的父级资源ID（只读）                                     |

### 使用指南总结

#### AsyncLocalStorage 使用步骤
1. 创建实例：`const als = new AsyncLocalStorage();`
2. 绑定上下文：用 `als.run(context, () => { ... })` 包裹初始同步/异步操作
3. 获取上下文：在任意嵌套的异步回调中通过 `als.getStore()` 获取 `context`
4. 注意事项：
   - 避免在 `run` 外部调用 `enterWith`（可能导致上下文混乱）
   - 仅对异步操作有效，不支持同步代码块间的上下文隔离

#### AsyncResource 使用步骤
1. 创建资源：`const resource = new AsyncResource('MY_RESOURCE');`
2. 包装异步操作：用 `resource.runInAsyncScope(() => { ... })` 执行自定义异步逻辑
3. 管理生命周期：必要时调用 `resource.emitDestroy()` 释放资源
4. 注意事项：
   - `type` 建议遵循 Node.js 资源命名规范（如 'TCPWRAP'、'PROMISE'）
   - 配合 `async_hooks` 时需注册钩子监听资源生命周期

### 案例Demo总结

#### AsyncLocalStorage：HTTP请求上下文追踪
```javascript
const http = require('http');
const { AsyncLocalStorage } = require('async_hooks');

const als = new AsyncLocalStorage();

// 模拟异步数据库查询
function fetchData() {
  const requestId = als.getStore(); // 获取当前请求ID
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(`数据结果（请求ID：${requestId}）`);
    }, 100);
  });
}

const server = http.createServer((req, res) => {
  const requestId = Date.now().toString(); // 生成唯一请求ID
  als.run(requestId, async () => {
    const data = await fetchData();
    res.end(`[${als.getStore()}] ${data}`); // 响应中包含请求ID
  });
});

server.listen(3000, () => {
  console.log('服务器运行在 http://localhost:3000');
});
```

## AsyncResource With worker

:::note

- 基础使用

> 初步验证 AsyncResource 和 Worker 线程的基础协作能力实现

> 让主线程能通过 `AsyncResource` 最终worker回调的异步上下文，建立跨线程的异步关联

```javascript
const { worker } = require('node:worker_threads');
const { AsyncResource } = require('node:async_hooks');

// 1. 创建子线程
const child_worker = new worker('./worker/child_worker.js')
// 2. 使用AsyncResource 进行实现包装Worker中的message回调，实现主线程的异步追踪 tracking
const resource = new AsyncResource('BASIC_WORKER');

child_worker.on('message', resource.runInAsyncScope(msg => {
    console.log('主线程接受到的消息', msg);
    resource.emitDestroy();  // 资源释放
}))

// 3. 实现向子线程进行发送信息
child_worker.postMessage('请处理我给你分发的任务哈！！！')

// =========./worker/child_worker.js==========
const { parentPort } = require('node:worker_threads');
parentPort.on('message', task => {
    setTimeout(() => {
        parentPort.postMessage(`已完成：${task}`);
    }, 100);
})
```
> **但是现在这个阶段只是完成了主线程和子线程之间的消息通信，但是在通信的时候进行context的传递没有实现呐**

- 解决线程间的上下文通信问题

> 核心使用 `AsyncLocalStorage` 进行主线程的上下文管理，实现上下文的数据关联

```javascript

const { worker } = require('node:worker_threads');
const { AsyncResource, AsyncLocalStorage } = require('node:async_hooks');

// 1. 初始化上下文管理容器
const als = new AsyncLocalStorage();

// 2. 实现可以上下文直接传递的工具函数
function runTaskWithContext(task) {
    return new Promise((resolve, reject) => {
        try {
            const child_worker = new worker('./worker/child_worker.js');
            const resource = new AsyncResource('WITH_CONTEXT_WORKER');
            child_worker.on('message', resource.runInAsyncScope(res => {
                // 在此时获取得到对应的上下文信息吧
                resolve({
                    ...res,
                    mainContext: als.getStore()
                })
                resource.emitDestroy();  // 资源及时释放
            }))

            child_worker.postMessage({
                task,
                context: als.getStore()
            })
        }
        catch (error) {
            reject(error);
        }
    })
}

// 3. 主线程执行上下文
als.run({
    // 实际可以通过 uuid 生成 traceId 吧
    traceId: 't1111',
    async () => {
        const res = await runTaskWithContext('这是追踪ID的封装吧'),
        console.log(`[${result.mainContext.traceId}] 最终结果：`, result.taskResult);
    }
})

// ==================
const { parentPort } = require('worker_threads');
parentPort.on('message', ({ task, context }) => {
    setTimeout(() => {
        // 处理任务并回传上下文
        parentPort.postMessage({
            taskResult: `处理完成：${task}`,
            workerContext: context // 保留主线程传递的上下文
        });
    }, 100);
});
```
> 使用的是`AsyncLocalStorage`实现存储主线程的上下文的信息，解决异步上下文的传递问题吧

> 最后通过 `postMessage` 进行实现显示的传递上下文信息，突破 Worker 与主线程的内存隔离限制，实现跨线程数据关联

> **但是现在还具备一个问题，就是我们的async_hooks器只能追踪自身所在线程的异步任务，子线程的追踪不了，但是核心的话是和上一阶段是一样呢**

- 实现子线程异步追踪

> 核心就是在子线程中处理的时候也进行对应的 asyncResource 的资源管理吧

```javascript
const { worker } = require('node:worker_threads');
const { AsyncResource, AsyncLocalStorage } = require('node:async_hooks');

// 1. 初始化上下文管理容器
const als = new AsyncLocalStorage();

// 2. 实现可以上下文直接传递的工具函数
function runTaskWithContext(task) {
    return new Promise((resolve, reject) => {
        try {
            const child_worker = new worker('./worker/child_worker.js');
            const resource = new AsyncResource('WITH_CONTEXT_WORKER');
            child_worker.on('message', resource.runInAsyncScope(res => {
                // 在此时获取得到对应的上下文信息吧
                resolve({
                    ...res,
                    mainContext: als.getStore()
                })
                resource.emitDestroy();  // 资源及时释放
            }))

            child_worker.postMessage({
                task,
                context: als.getStore()
            })
        }
        catch (error) {
            reject(error);
        }
    })
}

// 3. 主线程执行上下文
als.run({
    // 实际可以通过 uuid 生成 traceId 吧
    traceId: 't1111',
    async () => {
        const res = await runTaskWithContext('这是追踪ID的封装吧'),
        console.log(`[${result.mainContext.traceId}] 最终结果：`, result.taskResult);
    }
})

// ==================
const { parentPort } = require('worker_threads');
const { AsyncResource } = require('async_hooks');

function processTaskWithAsync(task, context) {
    return new Promise((resolve, reject) => {
        try {
            const resource = new AsyncResource('WORKER_INNER_TASK');
            setTimeout(resource.runInAsyncScope(() => {
                resolve('', task);
                resource.emitDestroy();
            }))
        }
        catch(error) {
            reject(error)
        }
    })
}

parentPort.on('message', ({ task, context }) => {
    const result = await processTaskAsync(task, context);
    parentPort.postMessage({ taskResult: result, workerContext: context });
});
```
> 核心就是使用我们的 `AsyncResource` 进行包装子线程的异步操纵，从而实现最后的的异步跟踪链的实现吧

* 工具封装

```javascript
class WorkerManager {
    constructor(workerFilePath, asyncResourceName, maxWorkers = 3) {
        this.workerPath = workerFilePath;
        this.asyncResourceName = asyncResourceName;
        this.als = new AsyncLocalStorage();
        this.workerPool = [];
        this.maxWorkers = maxWorkers;  // 最大并发数
    }

    _getWorker() {
        if (this.workerPool.length < this.maxWorkers) {
            const worker = new Worker(this.workerPath);
            worker.isBusy = false;  // 标记当前的状态
            this.workerPool.push(worker);
            return worker;
        }
        // 直接返回第一个不忙的worker
        return this.workerPool.find(w => !w.isBusy)
    }

    execute(task, context) {
        return this.als.run(context, () => {
            this._runWorker(task);
        })
    }

    _runWorker(task) {
        return new Promise((resolve, reject) => {
            const worker = this._getWorker();
            worker.isBusy = true;  // 直接标记为忙碌的 Worker
            const resource = new AsyncResource(this.asyncResourceName);

            // 异常处理
            const errorHandle = (err) => {
                resource.runInAsyncScope(() => {
                    reject('Worker Inner Error', err.message);
                })
                resource.emitDestroy();
                worker.isBusy = false;  // worker 置闲
            }
            worker.once('error', errorHandle);

            // 消息处理
            worker.once('message', resource.runInAsyncScope(res => {
                worker.isBusy = false;
                if (res.error) {
                    reject(res.error);
                }
                else {
                    resolve({
                        ...res,
                        mainContext: this.als.getStore();
                    })
                }
                resource.emitDestroy();
                worker.removeListener('error', errorHandle);
            }))

            worker.postMessage({
                task,
                context: this.als.getStore();
            })
        })
    }
}
```

:::

:::tip

- **核心知识点**
  - 线程隔离性：Worker 线程与主线程拥有独立的事件循环和内存空间，`async_hooks` 的追踪能力无法跨线程穿透，`AsyncResource` 仅能管理当前线程内的异步资源。
  - 上下文传递方式：主线程与 Worker 间的上下文（如追踪 ID、用户信息等）需通过 `postMessage` 显式传递，无法依赖 `AsyncLocalStorage` 自动共享。
  - 资源关联逻辑：在主线程中，可用 `AsyncResource` 包装 Worker 的 `message` 回调，将 Worker 回调与主线程的异步上下文关联；Worker 内部的异步操作则需单独用 `AsyncResource` 标记，确保线程内的异步链可追踪。
  - 生命周期管理：Worker 线程内创建的 `AsyncResource` 需在操作完成后调用 `emitDestroy()` 手动释放，避免内存泄漏；主线程中与 Worker 相关的 `AsyncResource` 需在 Worker 退出时同步销毁。

- **注意事项**
  - 避免跨线程共享 `AsyncLocalStorage` 实例：Worker 线程无法访问主线程的 `AsyncLocalStorage` 存储，需在 Worker 内重新初始化并基于传递的上下文数据重建存储。
  - 控制 `AsyncResource` 实例创建频率：高频 Worker 通信场景中，频繁创建 `AsyncResource` 会增加性能开销，可复用实例或批量处理关联操作。
  - 处理线程通信延迟：Worker 与主线程的消息传递是异步的，需确保 `AsyncResource` 包装的回调能正确关联消息发送时的上下文（而非接收时的上下文）。
  - 资源类型命名规范：自定义 `AsyncResource` 的 `type` 参数建议包含线程标识（如 `WORKER_MAIN`、`WORKER_THREAD_1`），便于在多线程日志中区分资源归属。
  - 异常处理边界：Worker 内的异步操作异常不会直接触发主线程的 `async_hooks` 错误钩子，需在 Worker 内捕获异常并通过消息传递给主线程，再结合主线程的 `AsyncResource` 标记错误上下文。

:::

:::info

```javascript
const { AsyncResource } = require('node:async_hooks');
const { EventEmitter } = require('node:events');
const path = require('node:path');
const { Worker } = require('node:worker_threads');

const kTaskInfo = Symbol('kTaskInfo');
const kWorkerFreedEvent = Symbol('kWorkerFreedEvent');

class WorkerPoolTaskInfo extends AsyncResource {
  constructor(callback) {
    super('WorkerPoolTaskInfo');
    this.callback = callback;
  }

  done(err, result) {
    this.runInAsyncScope(this.callback, null, err, result);
    this.emitDestroy();  // `TaskInfo`s are used only once.
  }
}

class WorkerPool extends EventEmitter {
  constructor(numThreads) {
    super();
    this.numThreads = numThreads;
    this.workers = [];
    this.freeWorkers = [];
    this.tasks = [];

    for (let i = 0; i < numThreads; i++)
      this.addNewWorker();

    // Any time the kWorkerFreedEvent is emitted, dispatch
    // the next task pending in the queue, if any.
    this.on(kWorkerFreedEvent, () => {
      if (this.tasks.length > 0) {
        const { task, callback } = this.tasks.shift();
        this.runTask(task, callback);
      }
    });
  }

  addNewWorker() {
    const worker = new Worker(path.resolve(__dirname, 'task_processor.js'));
    worker.on('message', (result) => {
      // In case of success: Call the callback that was passed to `runTask`,
      // remove the `TaskInfo` associated with the Worker, and mark it as free
      // again.
      worker[kTaskInfo].done(null, result);
      worker[kTaskInfo] = null;
      this.freeWorkers.push(worker);
      this.emit(kWorkerFreedEvent);
    });
    worker.on('error', (err) => {
      // In case of an uncaught exception: Call the callback that was passed to
      // `runTask` with the error.
      if (worker[kTaskInfo])
        worker[kTaskInfo].done(err, null);
      else
        this.emit('error', err);
      // Remove the worker from the list and start a new Worker to replace the
      // current one.
      this.workers.splice(this.workers.indexOf(worker), 1);
      this.addNewWorker();
    });
    this.workers.push(worker);
    this.freeWorkers.push(worker);
    this.emit(kWorkerFreedEvent);
  }

  runTask(task, callback) {
    if (this.freeWorkers.length === 0) {
      // No free threads, wait until a worker thread becomes free.
      this.tasks.push({ task, callback });
      return;
    }

    const worker = this.freeWorkers.pop();
    worker[kTaskInfo] = new WorkerPoolTaskInfo(callback);
    worker.postMessage(task);
  }

  close() {
    for (const worker of this.workers) worker.terminate();
  }
}

module.exports = WorkerPool;
```

:::

## In A Words:

:::note

* Node.js 中 `async_hooks` 模块及其核心组件 `AsyncLocalStorage`、`AsyncResource`，是实现异步操作链路追踪与上下文管理的关键工具。它们常与 `worker_threads`（多线程任务处理）、`EventEmitter`（事件驱动机制）协同，为高并发场景下的异步行为提供精细化管控能力，包括流程追踪、资源治理、异常监控等核心功能，是构建生产级异步应用的重要技术支撑。

### 利用async_hooks库的工具总结
- **性能分析工具**：借助 `async_hooks` 能够追踪异步操作的生命周期，像 `async-stack-traces` 这类工具，可以准确获取异步操作的调用栈信息，帮助开发者快速定位性能瓶颈，比如在复杂的异步 I/O 操作、数据库查询等场景中，明确是哪一个异步任务导致了性能问题。
 - **调试辅助工具**：`async-hook-debug` 等工具利用 `async_hooks` 对异步操作的追踪，能更清晰地展示异步代码的执行流程，在排查与异步操作相关的错误，如异步任务顺序错乱、回调未正确触发等问题时，提供了直观的信息，加快调试效率。
 - **资源管理工具**：一些用于管理资源的工具，通过 `async_hooks` 监听异步操作的创建和销毁，实现对资源的精细化管理。例如，在处理大量异步连接时，可及时回收不再使用的连接资源，避免资源泄漏。

### 将async_hooks集成到EFK中的核心思路
#### 扩展生态方面
- **数据采集**：在 Elasticsearch（ES）的摄入阶段，通过集成 `async_hooks` ，对应用程序产生的异步日志数据进行更全面、精准的采集。比如，在分布式系统中，异步操作可能跨越多个服务节点，利用 `async_hooks` 追踪这些异步操作，能确保将相关的日志信息完整收集到 ES 中，丰富生态中的数据来源。
 - **可视化增强**：在 Kibana 可视化层面，基于 `async_hooks` 收集到的异步操作链路数据，开发新的可视化插件。例如，以图形化的方式展示异步操作的调用关系和执行时间分布，使运维人员和开发者能更直观地理解系统中异步行为的全貌，拓展生态的可视化能力。
 - **生态对接**：将 `async_hooks` 相关功能与 EFK 生态中的其他工具进行对接，比如与 APM（应用性能管理）工具集成。通过 `async_hooks` 提供的异步操作数据，结合 APM 的性能指标分析，实现对应用程序性能更深入的洞察，扩大生态的功能边界。
 
#### 核心思路整理
 - **异步日志增强**：利用 `async_hooks` 对应用程序的异步操作进行标记和追踪，在日志记录时，为每条日志关联其所属的异步操作上下文信息。这样，在 Fluentd（或其他日志收集工具）进行日志传输，以及 ES 存储和检索时，能够更方便地按照异步操作维度进行查询和分析，提升 EFK 处理异步日志的能力。
 - **性能监控与告警**：通过 `async_hooks` 持续监控异步操作的执行时间、频率等指标，当发现异常时，将相关告警信息发送到 EFK 系统中。在 Kibana 中展示这些告警信息，并结合日志数据进行分析，帮助运维人员快速定位和解决性能问题，完善 EFK 的监控体系。 
 - **故障排查优化**：当系统出现故障时，依据 `async_hooks` 提供的异步操作链路信息，在 EFK 中快速关联和检索相关的日志记录。通过分析异步操作的先后顺序和执行状态，更高效地找出故障根源，提高 EFK 在故障排查场景下的效率和准确性。 

:::

:::info

* async_hooks enter ETK_STACK
```
+---------------------+        +-------------------+
| 应用程序异步操作       | ----> |  async_hooks 捕获   |
+---------------------+        +-------------------+
          |                            |
          | 产生异步事件                 | 提取上下文与链路信息
          v                            v
+---------------------+        +-------------------+
| 日志增强处理          | <----- |  async_hooks 捕获  |
+---------------------+        +-------------------+
          |
          | 添加异步元数据
          v
+---------------------+        +-------------------+
| Fluentd 日志收集     | -----> |      传输日志       |
+---------------------+        +-------------------+
          |                            |
          v                            v
+---------------------+        +-------------------+
| Elasticsearch 存储   | <----- |    数据索引与存储   |
+---------------------+        +-------------------+
          |
          v
+---------------------+
| Kibana 可视化分析     |
+---------------------+
          |
          v
+---------------------+
| 展示异步链路、监控告警  |
+---------------------+
          |
          v
+---------------------+
|    运维/开发人员分析   |
+---------------------+

# 性能指标分支
+-------------------+        +-------------------+
| async_hooks 捕获   | -----> |     性能指标采集    |
+-------------------+        +-------------------+
          |                            |
          v                            v
+-------------------+        +-------------------+
| APM 系统集成        | <-----|   性能数据关联到 ES  |
+-------------------+        +-------------------+
```


* async_hooks 性能分析工具
```
+---------------------+        +-------------------+
| 应用多异步任务执行     | -----> | async_hooks 监听   |
+---------------------+        +-------------------+
          |                            |
          | 异步操作创建/销毁             | 捕获生命周期事件
          v                            v
+---------------------+        +-------------------+
|AsyncResource 标记资源 | <-----|  async_hooks 监听  |
+---------------------+        +-------------------+
          |
          | 记录操作耗时、调用栈
          v
+---------------------+        +-------------------+
|   性能数据聚合        | -----> | async-stack-traces|
+---------------------+        +-------------------+
          |                            |
          | 生成性能指标                 | 展示异步调用链、性能瓶颈
          v                            v
+---------------------+        +-------------------+
| 开发者分析优化        | <----- | async-stack-traces|
+---------------------+        +-------------------+

# 异常追踪分支
+-------------------+        +-------------------+
| async_hooks 监听   | -----> | 异常异步操作识别     |
+-------------------+        +-------------------+
          |                            |
          v                            v
+-------------------+        +-------------------+
| 错误追踪工具集成     | <----- |   关联异步上下文    |
+-------------------+        +-------------------+
          |
          v
+-------------------+
| 错误日志系统        |
+-------------------+
```

* async_hooks 在性能分析工具中
```
+---------------------+        +----------------------+
| 分布式服务调用        | -----> | async_hooks 注入上下文 |
+---------------------+        +----------------------+
          |                            |
          | 跨服务异步请求               | 携带 traceId/spanId
          v                            v
+---------------------+        +-------------------+
| RPC 框架传输         | -----> | 跨服务传递上下文     |
+---------------------+        +-------------------+
          |                            |
          v                            v
+---------------------+        +----------------------+
| 各服务异步操作        | <----- | async_hooks 捕获上下文 |
+---------------------+        +----------------------+
          |
          | 服务内日志/指标收集
          v
+---------------------+        +--------------------------+
| 上报追踪数据          | -----> | 分布式追踪系统（如 Jaeger） |
+---------------------+        +--------------------------+
          |                            |
          | 整合跨服务异步链路            | 全局调用链可视化
          v                            v
+---------------------+        +--------------------------+
| 展示端到端异步流程     | <----- | 分布式追踪系统（如 Jaeger） |
+---------------------+        +--------------------------+
          |
          v
+---------------------+
| 运维/开发排查分布式问题 |
+---------------------+
```

:::
